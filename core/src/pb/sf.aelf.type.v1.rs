// @generated
// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transaction {
    /// The address of the sender of the transaction.
    #[prost(message, optional, tag="1")]
    pub from: ::core::option::Option<Address>,
    /// The address of the contract when calling a contract.
    #[prost(message, optional, tag="2")]
    pub to: ::core::option::Option<Address>,
    /// The height of the referenced block hash.
    #[prost(int64, tag="3")]
    pub ref_block_number: i64,
    /// The first four bytes of the referenced block hash.
    #[prost(bytes="vec", tag="4")]
    pub ref_block_prefix: ::prost::alloc::vec::Vec<u8>,
    /// The name of a method in the smart contract at the To address.
    #[prost(string, tag="5")]
    pub method_name: ::prost::alloc::string::String,
    /// The parameters to pass to the smart contract method.
    #[prost(bytes="vec", tag="6")]
    pub params: ::prost::alloc::vec::Vec<u8>,
    /// When signing a transaction itâ€™s actually a subset of the fields: from/to and the target method as well as 
    /// the parameter that were given. It also contains the reference block number and prefix.
    #[prost(bytes="vec", tag="10000")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatePath {
    /// The partial path of the state path.
    #[prost(string, repeated, tag="1")]
    pub parts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScopedStatePath {
    /// The scope address, which will be the contract address.
    #[prost(message, optional, tag="1")]
    pub address: ::core::option::Option<Address>,
    /// The path of contract state.
    #[prost(message, optional, tag="2")]
    pub path: ::core::option::Option<StatePath>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionResult {
    /// The transaction id.
    #[prost(message, optional, tag="1")]
    pub transaction_id: ::core::option::Option<Hash>,
    /// The transaction result status.
    #[prost(enumeration="TransactionResultStatus", tag="2")]
    pub status: i32,
    /// The log events.
    #[prost(message, repeated, tag="3")]
    pub logs: ::prost::alloc::vec::Vec<LogEvent>,
    /// Bloom filter for transaction logs. A transaction log event can be defined in the contract and stored 
    /// in the bloom filter after the transaction is executed. Through this filter, we can quickly search for 
    /// and determine whether a log exists in the transaction result.
    #[prost(bytes="vec", tag="4")]
    pub bloom: ::prost::alloc::vec::Vec<u8>,
    /// The return value of the transaction execution.
    #[prost(bytes="vec", tag="5")]
    pub return_value: ::prost::alloc::vec::Vec<u8>,
    /// The height of the block hat packages the transaction.
    #[prost(int64, tag="6")]
    pub block_number: i64,
    /// The hash of the block hat packages the transaction.
    #[prost(message, optional, tag="7")]
    pub block_hash: ::core::option::Option<Hash>,
    /// Failed execution error message.
    #[prost(string, tag="10")]
    pub error: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvalidTransactionResult {
    /// The transaction id.
    #[prost(message, optional, tag="1")]
    pub transaction_id: ::core::option::Option<Hash>,
    /// The transaction result status.
    #[prost(enumeration="TransactionResultStatus", tag="2")]
    pub status: i32,
    /// Failed execution error message.
    #[prost(string, tag="3")]
    pub error: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogEvent {
    /// The contract address.
    #[prost(message, optional, tag="1")]
    pub address: ::core::option::Option<Address>,
    /// The name of the log event.
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    /// The indexed data, used to calculate bloom.
    #[prost(bytes="vec", repeated, tag="3")]
    pub indexed: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// The non indexed data.
    #[prost(bytes="vec", tag="4")]
    pub non_indexed: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmartContractRegistration {
    /// The category of contract code(0: C#).
    #[prost(sint32, tag="1")]
    pub category: i32,
    /// The byte array of the contract code.
    #[prost(bytes="vec", tag="2")]
    pub code: ::prost::alloc::vec::Vec<u8>,
    /// The hash of the contract code.
    #[prost(message, optional, tag="3")]
    pub code_hash: ::core::option::Option<Hash>,
    /// Whether it is a system contract.
    #[prost(bool, tag="4")]
    pub is_system_contract: bool,
    /// The version of the current contract.
    #[prost(int32, tag="5")]
    pub version: i32,
    /// The version of the contract.
    #[prost(string, tag="6")]
    pub contract_version: ::prost::alloc::string::String,
    /// The address of the current contract.
    #[prost(message, optional, tag="7")]
    pub contract_address: ::core::option::Option<Address>,
    /// Indicates if the contract is the user contract.
    #[prost(bool, tag="8")]
    pub is_user_contract: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionExecutingStateSet {
    /// The changed states.
    #[prost(map="string, bytes", tag="1")]
    pub writes: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::vec::Vec<u8>>,
    /// The read states.
    #[prost(map="string, bool", tag="2")]
    pub reads: ::std::collections::HashMap<::prost::alloc::string::String, bool>,
    /// The deleted states.
    #[prost(map="string, bool", tag="3")]
    pub deletes: ::std::collections::HashMap<::prost::alloc::string::String, bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Address {
    #[prost(bytes="vec", tag="1")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Hash {
    #[prost(bytes="vec", tag="1")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SInt32Value {
    #[prost(sint32, tag="1")]
    pub value: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SInt64Value {
    #[prost(sint64, tag="1")]
    pub value: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MerklePath {
    /// The merkle path nodes.
    #[prost(message, repeated, tag="1")]
    pub merkle_path_nodes: ::prost::alloc::vec::Vec<MerklePathNode>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MerklePathNode {
    /// The node hash.
    #[prost(message, optional, tag="1")]
    pub hash: ::core::option::Option<Hash>,
    /// Whether it is a left child node.
    #[prost(bool, tag="2")]
    pub is_left_child_node: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BinaryMerkleTree {
    /// The leaf nodes.
    #[prost(message, repeated, tag="1")]
    pub nodes: ::prost::alloc::vec::Vec<Hash>,
    /// The root node hash.
    #[prost(message, optional, tag="2")]
    pub root: ::core::option::Option<Hash>,
    /// The count of leaf node.
    #[prost(int32, tag="3")]
    pub leaf_count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigIntValue {
    #[prost(string, tag="1")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TransactionResultStatus {
    /// The execution result of the transaction does not exist.
    NotExisted = 0,
    /// The transaction is in the transaction pool waiting to be packaged.
    Pending = 1,
    /// Transaction execution failed.
    Failed = 2,
    /// The transaction was successfully executed and successfully packaged into a block.
    Mined = 3,
    /// When executed in parallel, there are conflicts with other transactions.
    Conflict = 4,
    /// The transaction is waiting for validation.
    PendingValidation = 5,
    /// Transaction validation failed.
    NodeValidationFailed = 6,
}
impl TransactionResultStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TransactionResultStatus::NotExisted => "NOT_EXISTED",
            TransactionResultStatus::Pending => "PENDING",
            TransactionResultStatus::Failed => "FAILED",
            TransactionResultStatus::Mined => "MINED",
            TransactionResultStatus::Conflict => "CONFLICT",
            TransactionResultStatus::PendingValidation => "PENDING_VALIDATION",
            TransactionResultStatus::NodeValidationFailed => "NODE_VALIDATION_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NOT_EXISTED" => Some(Self::NotExisted),
            "PENDING" => Some(Self::Pending),
            "FAILED" => Some(Self::Failed),
            "MINED" => Some(Self::Mined),
            "CONFLICT" => Some(Self::Conflict),
            "PENDING_VALIDATION" => Some(Self::PendingValidation),
            "NODE_VALIDATION_FAILED" => Some(Self::NodeValidationFailed),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StateValue {
    #[prost(bytes="vec", tag="1")]
    pub current_value: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="2")]
    pub original_value: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StateChange {
    #[prost(message, optional, tag="1")]
    pub state_path: ::core::option::Option<StatePath>,
    #[prost(message, optional, tag="2")]
    pub state_value: ::core::option::Option<StateValue>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionTrace {
    #[prost(message, optional, tag="1")]
    pub transaction_id: ::core::option::Option<Hash>,
    #[prost(bytes="vec", tag="2")]
    pub return_value: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag="3")]
    pub error: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="4")]
    pub pre_transactions: ::prost::alloc::vec::Vec<Transaction>,
    #[prost(message, repeated, tag="5")]
    pub pre_traces: ::prost::alloc::vec::Vec<TransactionTrace>,
    #[prost(message, repeated, tag="6")]
    pub inline_transactions: ::prost::alloc::vec::Vec<Transaction>,
    #[prost(message, repeated, tag="7")]
    pub inline_traces: ::prost::alloc::vec::Vec<TransactionTrace>,
    #[prost(message, repeated, tag="8")]
    pub post_transactions: ::prost::alloc::vec::Vec<Transaction>,
    #[prost(message, repeated, tag="9")]
    pub post_traces: ::prost::alloc::vec::Vec<TransactionTrace>,
    #[prost(message, repeated, tag="10")]
    pub logs: ::prost::alloc::vec::Vec<LogEvent>,
    #[prost(int64, tag="11")]
    pub elapsed: i64,
    #[prost(enumeration="ExecutionStatus", tag="12")]
    pub execution_status: i32,
    #[prost(message, optional, tag="13")]
    pub state_set: ::core::option::Option<TransactionExecutingStateSet>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionReturnSet {
    #[prost(message, optional, tag="1")]
    pub transaction_id: ::core::option::Option<Hash>,
    #[prost(enumeration="TransactionResultStatus", tag="2")]
    pub status: i32,
    #[prost(map="string, bytes", tag="3")]
    pub state_changes: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::vec::Vec<u8>>,
    #[prost(map="string, bool", tag="4")]
    pub state_accesses: ::std::collections::HashMap<::prost::alloc::string::String, bool>,
    #[prost(bytes="vec", tag="5")]
    pub bloom: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="6")]
    pub return_value: ::prost::alloc::vec::Vec<u8>,
    #[prost(map="string, bool", tag="7")]
    pub state_deletes: ::std::collections::HashMap<::prost::alloc::string::String, bool>,
    #[prost(message, optional, tag="8")]
    pub transaction_result: ::core::option::Option<TransactionResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockHeaderList {
    #[prost(message, repeated, tag="1")]
    pub headers: ::prost::alloc::vec::Vec<BlockHeader>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockHeader {
    #[prost(int32, tag="1")]
    pub version: i32,
    #[prost(int32, tag="2")]
    pub chain_id: i32,
    #[prost(message, optional, tag="3")]
    pub previous_block_hash: ::core::option::Option<Hash>,
    #[prost(message, optional, tag="4")]
    pub merkle_tree_root_of_transactions: ::core::option::Option<Hash>,
    #[prost(message, optional, tag="5")]
    pub merkle_tree_root_of_world_state: ::core::option::Option<Hash>,
    #[prost(bytes="vec", tag="6")]
    pub bloom: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag="7")]
    pub height: i64,
    #[prost(map="string, bytes", tag="8")]
    pub extra_data: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::vec::Vec<u8>>,
    #[prost(message, optional, tag="9")]
    pub time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="10")]
    pub merkle_tree_root_of_transaction_status: ::core::option::Option<Hash>,
    #[prost(bytes="vec", tag="9999")]
    pub signer_pubkey: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="10000")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FirehoseBlockBody {
    #[prost(message, repeated, tag="1")]
    pub transactions: ::prost::alloc::vec::Vec<Transaction>,
    #[prost(message, repeated, tag="2")]
    pub trasanction_results: ::prost::alloc::vec::Vec<TransactionResult>,
    #[prost(message, repeated, tag="3")]
    pub transaction_traces: ::prost::alloc::vec::Vec<TransactionTrace>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockBody {
    #[prost(message, repeated, tag="1")]
    pub transaction_ids: ::prost::alloc::vec::Vec<Hash>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Block {
    #[prost(message, optional, tag="1")]
    pub header: ::core::option::Option<BlockHeader>,
    #[prost(message, optional, tag="2")]
    pub body: ::core::option::Option<BlockBody>,
    #[prost(message, optional, tag="7001")]
    pub firehose_body: ::core::option::Option<FirehoseBlockBody>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VersionedState {
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
    #[prost(bytes="vec", tag="2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag="3")]
    pub block_height: i64,
    #[prost(message, optional, tag="4")]
    pub block_hash: ::core::option::Option<Hash>,
    #[prost(message, optional, tag="5")]
    pub origin_block_hash: ::core::option::Option<Hash>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockStateSet {
    #[prost(message, optional, tag="1")]
    pub block_hash: ::core::option::Option<Hash>,
    #[prost(message, optional, tag="2")]
    pub previous_hash: ::core::option::Option<Hash>,
    #[prost(int64, tag="3")]
    pub block_height: i64,
    #[prost(map="string, bytes", tag="4")]
    pub changes: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::vec::Vec<u8>>,
    #[prost(string, repeated, tag="5")]
    pub deletes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(map="string, bytes", tag="6")]
    pub block_executed_data: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChainStateInfo {
    #[prost(int32, tag="1")]
    pub chain_id: i32,
    #[prost(message, optional, tag="2")]
    pub block_hash: ::core::option::Option<Hash>,
    #[prost(int64, tag="3")]
    pub block_height: i64,
    #[prost(message, optional, tag="4")]
    pub merging_block_hash: ::core::option::Option<Hash>,
    #[prost(enumeration="ChainStateMergingStatus", tag="5")]
    pub status: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChainBlockLink {
    #[prost(message, optional, tag="1")]
    pub block_hash: ::core::option::Option<Hash>,
    #[prost(int64, tag="2")]
    pub height: i64,
    #[prost(message, optional, tag="3")]
    pub previous_block_hash: ::core::option::Option<Hash>,
    #[prost(enumeration="ChainBlockLinkExecutionStatus", tag="4")]
    pub execution_status: i32,
    #[prost(bool, tag="5")]
    pub is_irreversible_block: bool,
    #[prost(bool, tag="6")]
    pub is_linked: bool,
    /// no block body
    #[prost(bool, tag="7")]
    pub is_light_block: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Chain {
    #[prost(int32, tag="1")]
    pub id: i32,
    #[prost(message, optional, tag="2")]
    pub genesis_block_hash: ::core::option::Option<Hash>,
    #[prost(message, optional, tag="3")]
    pub longest_chain_hash: ::core::option::Option<Hash>,
    #[prost(int64, tag="4")]
    pub longest_chain_height: i64,
    #[prost(map="string, int64", tag="5")]
    pub branches: ::std::collections::HashMap<::prost::alloc::string::String, i64>,
    #[prost(map="string, string", tag="6")]
    pub not_linked_blocks: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(message, optional, tag="7")]
    pub last_irreversible_block_hash: ::core::option::Option<Hash>,
    #[prost(int64, tag="8")]
    pub last_irreversible_block_height: i64,
    #[prost(message, optional, tag="9")]
    pub best_chain_hash: ::core::option::Option<Hash>,
    #[prost(int64, tag="10")]
    pub best_chain_height: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChainBlockIndex {
    #[prost(message, optional, tag="1")]
    pub block_hash: ::core::option::Option<Hash>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockIndex {
    #[prost(message, optional, tag="1")]
    pub block_hash: ::core::option::Option<Hash>,
    #[prost(int64, tag="2")]
    pub block_height: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionBlockIndex {
    #[prost(message, optional, tag="1")]
    pub block_hash: ::core::option::Option<Hash>,
    #[prost(int64, tag="2")]
    pub block_height: i64,
    #[prost(message, repeated, tag="3")]
    pub previous_execution_block_index_list: ::prost::alloc::vec::Vec<BlockIndex>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmartContractAddress {
    #[prost(message, optional, tag="1")]
    pub address: ::core::option::Option<Address>,
    #[prost(message, optional, tag="2")]
    pub block_hash: ::core::option::Option<Hash>,
    #[prost(int64, tag="3")]
    pub block_height: i64,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TransactionStatus {
    UnknownTransactionStatus = 0,
    TransactionExecuting = 1,
    TransactionExecuted = 2,
}
impl TransactionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TransactionStatus::UnknownTransactionStatus => "UNKNOWN_TRANSACTION_STATUS",
            TransactionStatus::TransactionExecuting => "TRANSACTION_EXECUTING",
            TransactionStatus::TransactionExecuted => "TRANSACTION_EXECUTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN_TRANSACTION_STATUS" => Some(Self::UnknownTransactionStatus),
            "TRANSACTION_EXECUTING" => Some(Self::TransactionExecuting),
            "TRANSACTION_EXECUTED" => Some(Self::TransactionExecuted),
            _ => None,
        }
    }
}
/// For failed transactions, its status follows the Min of
/// its own status and its inline transactions'
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExecutionStatus {
    Undefined = 0,
    /// Successful =>
    Executed = 1,
    /// Failed =>
    ///    Infrastructure reasons
    Canceled = -1,
    SystemError = -2,
    ///    Contract reasons
    ContractError = -10,
    ExceededMaxCallDepth = -11,
    /// Pre-failed
    Prefailed = -99,
    /// Post-failed
    Postfailed = -199,
}
impl ExecutionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ExecutionStatus::Undefined => "UNDEFINED",
            ExecutionStatus::Executed => "EXECUTED",
            ExecutionStatus::Canceled => "CANCELED",
            ExecutionStatus::SystemError => "SYSTEM_ERROR",
            ExecutionStatus::ContractError => "CONTRACT_ERROR",
            ExecutionStatus::ExceededMaxCallDepth => "EXCEEDED_MAX_CALL_DEPTH",
            ExecutionStatus::Prefailed => "PREFAILED",
            ExecutionStatus::Postfailed => "POSTFAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNDEFINED" => Some(Self::Undefined),
            "EXECUTED" => Some(Self::Executed),
            "CANCELED" => Some(Self::Canceled),
            "SYSTEM_ERROR" => Some(Self::SystemError),
            "CONTRACT_ERROR" => Some(Self::ContractError),
            "EXCEEDED_MAX_CALL_DEPTH" => Some(Self::ExceededMaxCallDepth),
            "PREFAILED" => Some(Self::Prefailed),
            "POSTFAILED" => Some(Self::Postfailed),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChainStateMergingStatus {
    Common = 0,
    Merging = 1,
    Merged = 2,
}
impl ChainStateMergingStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ChainStateMergingStatus::Common => "COMMON",
            ChainStateMergingStatus::Merging => "MERGING",
            ChainStateMergingStatus::Merged => "MERGED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMMON" => Some(Self::Common),
            "MERGING" => Some(Self::Merging),
            "MERGED" => Some(Self::Merged),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChainBlockLinkExecutionStatus {
    ExecutionNone = 0,
    ExecutionSuccess = 1,
    ExecutionFailed = 2,
}
impl ChainBlockLinkExecutionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ChainBlockLinkExecutionStatus::ExecutionNone => "EXECUTION_NONE",
            ChainBlockLinkExecutionStatus::ExecutionSuccess => "EXECUTION_SUCCESS",
            ChainBlockLinkExecutionStatus::ExecutionFailed => "EXECUTION_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EXECUTION_NONE" => Some(Self::ExecutionNone),
            "EXECUTION_SUCCESS" => Some(Self::ExecutionSuccess),
            "EXECUTION_FAILED" => Some(Self::ExecutionFailed),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
