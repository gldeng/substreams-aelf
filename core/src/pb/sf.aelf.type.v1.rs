// @generated
// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Block {
    #[prost(int32, tag="1")]
    pub version: i32,
    #[prost(string, tag="2")]
    pub block_hash: ::prost::alloc::string::String,
    #[prost(int64, tag="3")]
    pub height: i64,
    #[prost(message, optional, tag="4")]
    pub header: ::core::option::Option<BlockHeader>,
    #[prost(message, repeated, tag="5")]
    pub transaction_traces: ::prost::alloc::vec::Vec<TransactionTrace>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionTrace {
    #[prost(string, tag="1")]
    pub transaction_id: ::prost::alloc::string::String,
    #[prost(bytes="vec", tag="2")]
    pub raw_transaction: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="3")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag="4")]
    pub calls: ::prost::alloc::vec::Vec<Call>,
    #[prost(int32, tag="5")]
    pub main_call_index: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Call {
    /// Transaction id format <root_tx_id>:(pre/post:)1:1:1
    #[prost(string, tag="1")]
    pub transaction_id: ::prost::alloc::string::String,
    /// sub transactions are `:(pre/post:)1:1:1`
    #[prost(string, tag="2")]
    pub call_path: ::prost::alloc::string::String,
    /// The height of the referenced block hash.
    #[prost(int64, tag="3")]
    pub ref_block_number: i64,
    /// The first four bytes of the referenced block hash.
    #[prost(string, tag="4")]
    pub ref_block_prefix: ::prost::alloc::string::String,
    #[prost(string, tag="5")]
    pub from: ::prost::alloc::string::String,
    #[prost(string, tag="6")]
    pub to: ::prost::alloc::string::String,
    #[prost(string, tag="7")]
    pub method_name: ::prost::alloc::string::String,
    #[prost(bytes="vec", tag="8")]
    pub params: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration="ExecutionStatus", tag="9")]
    pub execution_status: i32,
    #[prost(bytes="vec", tag="10")]
    pub return_value: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag="11")]
    pub error: ::prost::alloc::string::String,
    #[prost(message, optional, tag="12")]
    pub state_set: ::core::option::Option<TransactionExecutingStateSet>,
    #[prost(message, repeated, tag="13")]
    pub logs: ::prost::alloc::vec::Vec<LogEvent>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionExecutingStateSet {
    /// The changed states.
    #[prost(map="string, bytes", tag="1")]
    pub writes: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::vec::Vec<u8>>,
    /// The read states.
    #[prost(map="string, bool", tag="2")]
    pub reads: ::std::collections::HashMap<::prost::alloc::string::String, bool>,
    /// The deleted states.
    #[prost(map="string, bool", tag="3")]
    pub deletes: ::std::collections::HashMap<::prost::alloc::string::String, bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogEvent {
    /// The contract address.
    #[prost(string, tag="1")]
    pub address: ::prost::alloc::string::String,
    /// The name of the log event.
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    /// The indexed data, used to calculate bloom.
    #[prost(bytes="vec", repeated, tag="3")]
    pub indexed: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// The non indexed data.
    #[prost(bytes="vec", tag="4")]
    pub non_indexed: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockHeader {
    #[prost(int32, tag="1")]
    pub version: i32,
    #[prost(int32, tag="2")]
    pub chain_id: i32,
    #[prost(string, tag="3")]
    pub previous_block_hash: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub merkle_tree_root_of_transactions: ::prost::alloc::string::String,
    #[prost(string, tag="5")]
    pub merkle_tree_root_of_world_state: ::prost::alloc::string::String,
    #[prost(bytes="vec", tag="6")]
    pub bloom: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag="7")]
    pub height: i64,
    #[prost(map="string, bytes", tag="8")]
    pub extra_data: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::vec::Vec<u8>>,
    #[prost(message, optional, tag="9")]
    pub time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag="10")]
    pub merkle_tree_root_of_transaction_status: ::prost::alloc::string::String,
    #[prost(bytes="vec", tag="9999")]
    pub signer_pubkey: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="10000")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExecutionStatus {
    Undefined = 0,
    /// Successful =>
    Executed = 1,
    /// Failed =>
    ///    Infrastructure reasons
    Canceled = -1,
    SystemError = -2,
    ///    Contract reasons
    ContractError = -10,
    ExceededMaxCallDepth = -11,
    /// Pre-failed
    Prefailed = -99,
    /// Post-failed
    Postfailed = -199,
}
impl ExecutionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ExecutionStatus::Undefined => "UNDEFINED",
            ExecutionStatus::Executed => "EXECUTED",
            ExecutionStatus::Canceled => "CANCELED",
            ExecutionStatus::SystemError => "SYSTEM_ERROR",
            ExecutionStatus::ContractError => "CONTRACT_ERROR",
            ExecutionStatus::ExceededMaxCallDepth => "EXCEEDED_MAX_CALL_DEPTH",
            ExecutionStatus::Prefailed => "PREFAILED",
            ExecutionStatus::Postfailed => "POSTFAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNDEFINED" => Some(Self::Undefined),
            "EXECUTED" => Some(Self::Executed),
            "CANCELED" => Some(Self::Canceled),
            "SYSTEM_ERROR" => Some(Self::SystemError),
            "CONTRACT_ERROR" => Some(Self::ContractError),
            "EXCEEDED_MAX_CALL_DEPTH" => Some(Self::ExceededMaxCallDepth),
            "PREFAILED" => Some(Self::Prefailed),
            "POSTFAILED" => Some(Self::Postfailed),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
